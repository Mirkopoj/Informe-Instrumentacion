\documentclass[12pt,letterpaper]{article}     % Tipo de documento y otras especificaciones
\usepackage[utf8]{inputenc}                   % Para escribir tildes y eñes
\usepackage[spanish]{babel}                   % Para que los títulos de figuras, tablas y otros estén en español
\addto\captionsspanish{\renewcommand{\tablename}{Tabla}}					% Cambiar nombre a tablas
\addto\captionsspanish{\renewcommand{\listtablename}{Índice de tablas}}		% Cambiar nombre a lista de tablas
\usepackage{geometry}                         
\geometry{left=18mm,right=18mm,top=21mm,bottom=21mm} % Tamaño del área de escritura de la página
\usepackage{ucs}
\usepackage{amsmath}      % Los paquetes ams son desarrollados por la American Mathematical Society
\usepackage{amsfonts}     % y mejoran la escritura de fórmulas y símbolos matemáticos.
\usepackage{amssymb}
\usepackage{graphicx}     % Para insertar gráficas
\usepackage[lofdepth,lotdepth]{subfig}	% Para colocar varias figuras
\usepackage{unitsdef}	  % Para la presentación correcta de unidades
\usepackage{pdfpages}   %incluir paginas de pdf externo, para los anexos
\usepackage{appendix}   %para los anexos
\renewcommand{\unitvaluesep}{\hspace*{4pt}}	% Redimensionamiento del espacio entre magnitud y unidad
\usepackage[colorlinks=true,urlcolor=blue,linkcolor=black,citecolor=black]{hyperref}     % Para insertar hipervínculos y marcadores
\usepackage{float}		% Para ubicar las tablas y figuras justo después del texto
\usepackage{booktabs}	% Para hacer tablas más estilizadas
\usepackage{color}
\batchmode
%\bibliographystyle{plain} 
\pagestyle{plain} 
\pagenumbering{arabic}
\usepackage{lastpage}
\usepackage{fancyhdr}	% Para manejar los encabezados y pies de página
\usepackage{mdframed}
\pagestyle{fancy}		% Contenido de los encabezados y pies de pagina
\setlength{\headheight}{15pt}
\usepackage{multicol}   % Para varias columnas
\usepackage[export]{adjustbox}
\usepackage{ragged2e}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{circuitikz}
\usepackage{cancel}
\usepackage{color}
\usepackage{listings}
\lstset{ %
language=C++,                % choose the language of the code
basicstyle=\footnotesize,       % the size of the fonts that are used for the code
numbers=left,                   % where to put the line-numbers
numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
stepnumber=1,                   % the step between two line-numbers. If it is 1 each line will be numbered
numbersep=5pt,                  % how far the line-numbers are from the code
backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
frame=single,           % adds a frame around the code
tabsize=2,          % sets default tabsize to 2 spaces
captionpos=b,           % sets the caption-position to bottom
breaklines=true,        % sets automatic line breaking
breakatwhitespace=false,    % sets if automatic breaks should only happen at whitespace
escapeinside={\%*}{*)}          % if you want to add a comment within your code
}
%%%%
%---------------------------Definición del environment resumen---------------------------
\newcounter{resumen}
\setcounter{resumen}{0}
\def\theejemplo{\thechapter.\arabic{resumen}}

\newenvironment{resumen}
{	
	\begin{center}
	\begin{minipage}[t]{500 pt}
	\vspace{5mm}
	\emph{\textbf{Resumen}}
	\\[-2mm]
	\line(1,0){500}
	\\[-4.25 mm]
	\line(1,0){500}
	\vspace{\baselineskip}
}
{
	\normalsize
	\\[2mm]
	\footnotesize\textbf{Palabras clave: \footnotesize\@palabras}
	\\[-2mm]
	\line(1,0){500}
	\\[0.5cm]
	\end{minipage}
	\end{center}
}

% -------------------- Para las palabras clave -------------- %
\def\palabras#1{\gdef\@palabras{#1}}

%---------------------------Definición del float circuito---------------------------
\newfloat{circuito}{thp}{lop}
\floatname{circuito}{Circuito}

%---------------------------Definición del float código---------------------------
\newfloat{codigo}{thp}{lop}
\floatname{codigo}{Código}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\lhead{B5692 - Plataforma de programación y prueba para PCB}
\chead{}
\rhead{Desarrollo de maqueta y HMI}	% Aquí va el numero de experimento, al igual que en el titulo
\lfoot{Ingeniería Electrónica}
\cfoot{\thepage\ de \pageref{LastPage}}
\rfoot{Universidad Nacional de Río Negro}

%%%%%%%%%%%%%%%%% PALABRAS CLAVE 
\palabras{Punto de trabajo, pequeña señal, analíticamente, simulación, laboratorio}
%%%%%%%%%%%%%%%%%
% Se escriben después del resumen y sintetizan los conceptos fundamentales del experimento a modo de etiquetas


%%%%%%%%%%%%%%%%
\begin{document}	% Inicio del documento
%%%%%%%%%%%%%%%%
\pdfbookmark[1]{Portada}{portada} 	% Marcador para el título

\begin{titlepage}
\centering
{\includegraphics[width=0.2\textwidth]{imagenes/LOGOUNRN.jpg}\par}
\vspace{0.5cm}
{\bfseries\large Universidad Nacional de Río Negro \par}
\vspace{0.5cm}
{\scshape\large Escuela de Producción, Tecnología y Medio Ambiente \par}
\vspace{0.5cm}
{\scshape\large Ingeniería Electrónica \par}
\vspace{3cm}
{\bfseries\Large Plataforma de programación y prueba para PCB \par}
{\Large Desarrollo de maqueta y HMI\par}
\vfill
{\large \textbf{Alumno:} Mirko Manuel Pojmaevich\par}
{\large \textbf{Profesores:} Gelardi Gustavo\par}
{\large \textbf{Materia:} Electrónica Analógica | \textbf{Código:} B5692\par}
\vspace{3cm}
{\large Fecha de entrega: 10 de noviembre de 2022 \par}
\vspace{1cm}
\begin{table*}[!ht]
\begin{center}
\begin{tabular}{| c | c | c | c |}
\hline
\textbf{Rev.} & \textbf{Fecha} & \textbf{Profesor} & \textbf{Nota} \\ 
\hline
 &  & & \\
 \hline
 & & &  \\
\hline
\end{tabular}
\end{center}
\end{table*}
\end{titlepage}
%\maketitle							% Título
\newpage
\tableofcontents
\newpage
\listoffigures
%\listoftables

\newpage
%palabras claves
\section{Resumen}
%%%%%%%%%%%%%%%%%%%
\begin{resumen}
	Se presenta un sistema automático para la validación de circuitos electrónicos.
	Este inyecta señales en la placa siendo probada y mide las respuestas.
	Es capaz de medir tanto señales digitales como niveles analógicos de tensión.
	Para circuitos que incluyen un microcontrolador, de tipo PIC, el sistema es capaz de programar
	firmware, permitiendo probar la correcta funcionalidad de los módulos internos
	del dispositivo. El sistema clasifica los circuitos probados separando los
	funcionales de los defectuosos de acuerdo al conjunto de reglas que se le den.
	El estado de las pruebas puede ser monitoreado mediante un HMI.
\end{resumen} 
%%%%%%%%%%%%%%%%%%% 
%\section{Objetivos} 
% 
%\begin{itemize} 
%\item Aplicar mediante un ejemplo práctico conocimientos vistos en la materia.
%\item Ampliar conocimientos y herramientas referidas a filtros.
%\end{itemize}
%\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Marco teórico}
\label{Marco teórico}

\subsection{Pogopins}

Se conoce como Pogopin a un tipo de contacto con muelle como el que se muestra en la figura \ref{fig:pogopin}.
Este permite realizar una conexión con una circuito impreso con únicamente un pad expuesto de forma robotizada.

\begin{figure}[!ht]
\centering
\includegraphics[]{imagenes/pogopin.jpg}
\caption{Ejemplo de Pogopins}
\label{fig:pogopin}
\end{figure}

\subsection{SBC}

SCB son las siglas en ingles de Single Board Computer, refieren a una computadora completamente contenida en una
única placa de circuito impreso. El ejemplo mas popular es la RaspberryPi.

\subsection{/dev}

En el sistema de directorios de Linux el directorio \textbf{/dev} es uno que contiene archivos especiales 
o de tipo dispositivo. En su mayoría los archivos contenidos en este directorio permiten interactuar con el
hardware, tratando a los dispositivos físicos del sistema como parte del sistema de ficheros. Esto funciona 
asociando los canales de lectura y escritura de los archivos con los dispositivos físicos. Por ejemplo,
si se escribe al archivo \textbf{/dev/dsp}, el cual representa los parlantes, se escuchará un sonido. Para el correcto
funcionamiento de los dispositivos se debe respetar el protocolo mediante el cual se interactúa con estos archivos.

\subsubsection{Módulos del kernel}

No todos los archivos bajo \textbf{/dev} representan un dispositivo, algunos representan extensiones del kernel de Linux.
Estas extensiones generalmente interactúan con uno o mas dispositivos físicos bajo un protocolo distinto, esto
con el fin de encapsular, simplificar o incluso hacer posibles ciertas funcionalidades. Por ejemplo,
existe una extensión de kernel para el manejo de LCDs, estos podrían ser controlados mediante escritura a los
ficheros de entrada-salida o algún fichero de un módulo de comunicación serie, en ambos casos lo que se 
escribe en los archivos de \textbf{/dev} no es lo que se desea obtener, sino que se debe traducir el mensaje mediante el
software y realizar múltiples llamados al sistema desde el entorno de usuario para la escritura. En el caso de un
módulo de kernel dedicado, se puede escribir la información final que se desea obtener, la traducción y envío del
mensaje ocurrirá en espacio del kernel de forma muy eficiente con una única llamada al sistema. 

\subsection{Rust}

Es un lenguaje de programación de sistemas orientado a la seguridad y la eficiencia. 
Rust es un lenguaje compilado de alto nivel, que no utiliza un recolector de basura, 
como lo hace Java por ejemplo. Permite un control fino de la memoria similar al de 
C o C++, pero a diferencia de estos, Rust no utiliza un paradigma de alocación y 
liberación explicita de memoria, sino que se basa un ``Borrow checker''.
El ``Borrow checker'' consiste de un conjunto de reglas que limitan como se puede 
programar en Rust, respetando estas reglas se obtienen un conjunto de garantías.
Estas garantías incluyen un código libre de fugaz de memoria, inmunidad a condiciones 
de carrera y validez de los datos al los que se accede. 
Existen situaciones en las que el ``Borrow checker'' es demasiado estricto y para
garantizar la seguridad opta por no compilar un código valido, antes que dar por valido
un programa que pudiera fallar en algún escenario. Esto puede ser un problema cuando 
se tiene un que acceder al hardware, por ejemplo si se quiere acceder a algún registro 
de la plataforma que se esta utilizando, el ``Borrow checker'' no tiene forma de garantizar
que dicho registro exista, depende del programador conocer la plataforma en la que se va a 
ejecutar el programa, para ello existe un tipo de bloque de código llamado ``unsafe'', todo
programa contenido en un bloque con esta etiqueta será compilado sin revisión del ``Borrow checker''.

\clearpage
\section{Materiales}

En esta sección se describen los elementos utilizados para la realización del proyecto, no se discute si la
elección fue óptima porque estos son productos de los que se disponía con antelación.

\subsection{NanoPi Neo3}

El NanoPi Neo3 es una SBC compacta y de bajo costo. Utiliza un CPU Rockchip RK3328 de cuatro núcleos, con
arquitectura ARM Cortex-A53. Cuenta con 1 ó 2 GB de memoria RAM, y Gbps Ethernet. 

\begin{figure}[!ht]
\centering
\includegraphics[scale=0.5]{imagenes/naopi.jpg}
\caption{NanoPi Neo3}
\label{fig:nanopi}
\end{figure}

Esta SCB interactúa con los sensores y motores coordinando el funcionamiento de la plataforma.
A su vez, esta se encarga de programar los microcontroladores, inyectar las señales y leer 
las respuestas digitales. Como la mayoría de SCBs no contienen un ADCs incorporado, se utiliza
un dispositivo externo para la medición analógica de niveles de tensión, los que luego son
comunicados mediante el protocolo I2C.

Por último, este SCB actúa como host de un servidor TCP, para que múltiples usuarios puedan acceder
al HMI de forma remota.

\subsection{PIC18F45K50}

Este microcontrolador es el dispositivo externo antes mencionado, que actúa como ADC y comunica los
valores de tensión medidos mediante I2C. Este resulta mucho mas capaz de lo requerido para la tarea.

\subsection{Motorreductor}

Para movilizar la cinta se utiliza un motor con una reducción 1:48 y salida en doble eje TT de marca
genérica similar al que se muestra en la figura \ref{fig:motor}.

\begin{figure}[!ht]
\centering
\includegraphics[scale=0.25]{imagenes/motorreductor.jpg}
\caption{Motorreductor}
\label{fig:motor}
\end{figure}

\subsection{Servo motor}

Los servo motores utilizados son micro servos, modelo MG90S, de la marca Tower Pro, como el que
se muestra en la figura \ref{fig:servo}. Este cuenta con un torque de $1,8\kilogram f$ a $4,8\volt$
y $2,2\kilogram f$ a $6\volt$.

\begin{figure}[!ht]
\centering
\includegraphics[scale=0.15]{imagenes/servo.jpg}
\caption{Servo motor}
\label{fig:servo}
\end{figure}

\subsection{Sensor óptico}

Para detectar la presencia de una placa en los puntos relevantes del proceso, se utilizaron sensores ópticos.
Estos consisten en un led y un fototransistor, dispuestos de manera tal que el led permita que el fototransistor
sature, la detección ocurre cuando un objeto obstruye el paso de luz, causando que el fototransistor entre en
corte. Su aspecto y diagrama esquemático se pueden ver en la figura \ref{fig:sensoptico}.

\begin{figure}[!h]
	\begin{minipage}{.5\textwidth}
		\begin{center}
			\begin{circuitikz}[american,]
				\draw (0,0) node[npn, photo](Q1){};
				\draw (Q1.E) to[short]
					++(0,0)
					to[short]
					++(-2,0)
					node[](gnd){};
				\draw (Q1.C) to [short, -o] 
					++(1.5, 0)
					node[](out){};
				\draw (-2,0.6) 
					to[leD]
					++(0,-1)
					to[short]
					(gnd |- gnd);
				\draw (-2,0.6)
					to[short]
					(gnd |- out)
					to[short, -o]
					++(-1.5,0);
				\draw (-1,-0.77)
					to[short, *-o]
					++(0,-1);
			\end{circuitikz}
		\end{center}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}
		\begin{center}
			\includegraphics[scale=0.3]{imagenes/optico.jpg}
		\end{center}
	\end{minipage}
\caption{Sensor óptico}
\label{fig:sensoptico}
\end{figure}

\section{Estructura}

Para automatizar las pruebas sobre los circuitos se suele utilizar una cama de Pogopins, 
estas pueden estar completamente robotizadas, como la que se presenta, o pueden ser manuales,
como la que se muestra en la figura \ref{fig:pogojig}.

Para la construcción de esta plataforma se decidió un diseño basado en una cinta transportadora.
Esta llevaría las placas hasta que estén debajo de la cama de pines, donde un sensor óptico detectaría 
su presencia, deteniendo la cinta. Con la placa bajo la cama, un servo motor conectado a una leva 
bajaría la cama. Con los Pogopins haciendo contacto con la placa, se quemaría el firmware de prueba.
Luego se inyectarían valores de tensión y se pro

\begin{figure}[!ht]
\centering
\includegraphics[scale=0.1]{imagenes/pogojig.jpg}
\caption{Ejemplo de ``test jig manual''}
\label{fig:pogojig}
\end{figure}

\section{Pickle}

Para poder realizar la programación de los PIC se utiliza el software Pickle. 
Este provee un mecanismo para interactuar con el microcontrolador y quemar en él un firmware.
Su instalación es sencilla y puede lograrse con los comandos mostrados en el Código \ref{code:instalacionPickle}.
Sin embargo, este sólo posee soporte nativo para una contada selección de SBCs populares. En el caso del NanoPi NEO3,
el programa depende de un módulo externo del kernel de Linux llamado GPIO BIT BANG.
Compilar módulos del kernel requiere de la instalación de los headers del kernel, los cuales están asociados al kernel
que se tiene instalado, el que a su vez depende de la arquitectura en la que se trabaje. Los paquetes de headers en los
repositorios de Linux suelen seguir un consenso en sus nombres, bajo la siguiente estructura, 
$linux-headers-\$(uname -r)$. En el caso del NanoPi NEO3, este consenso se rompe siendo el nombre del paquete, 
$linux-headers-current-rockchip64$. Una vez instalados los headers del kernel, uno debe asegurarse de que exista
un enlace simbólico, del directorio $/lib/modules/\$(uname -r)/build$ al directorio $/usr/src/$.
Una vez que todas las herramientas para la extensión del kernel estén en su lugar, se puede instalar el módulo 
GPIO BIT BANG mediante los comandos mostrados en el Código \ref{code:instalacionGPIOBB} (el comando $hg$ requiere
de la instalación de mercurial).

\begin{codigo}[]
	\begin{lstlisting}
	cd /tmp
	wget http://wiki.kewl.org/downloads/pickle-4.20.tgz 
	tar zxf pickle-4.20.tgz 
	cd pickle-4.20/
	make
	sudo make install
	\end{lstlisting}
	\caption{Instalación Pickle}
	\label{code:instalacionPickle}
\end{codigo}

\begin{codigo}[!h]
	\begin{lstlisting}
	hg clone http://hg.kewl.org/pub/gpio-bb
	cd gpio-bb
	make
	sudo make install
	\end{lstlisting}
	\caption{Instalación GPIO BIT BANG}
	\label{code:instalacionGPIOBB}
\end{codigo}

\newpage
\section{Ejercicios}
\begin{mdframed}
	\begin{itemize}
		\item Análisis en CC
		\begin{enumerate}
			\item Busque la hoja de datos del transistor BC547 y obtenga los siguientes valores:
			\begin{itemize}
				\item Ganancia de corriente ($h_{fe}$)
				\item Tensión base-emisor de encendido ($V_{BE}$)
				\item Tensión colector-emisor máxima ($V_{CEmax}$)
				\item Tensión colector-emisor de saturación ($V_{CEsat}$)
				\item Corriente de colector máxima
			\end{itemize}
			\item Con los datos obtenidos, resuelva el circuito que se muestra en la figura \ref{circuito1} 
				analíticamente para CC ($V_{in}=0$). Halle el punto de trabajo y grafíquelo.
			\item Simúlelo y obtenga el punto de trabajo mediante simulación. Compare con lo calculado analíticamente.
		\end{enumerate}
		\item Análisis en CA
		\begin{enumerate}
			\item Resuelva el circuito \ref{circuito2} analíticamente para CA
			\item Simúlelo y compare con los resultados obtenidos analíticamente.
			\item ¿Qué diferencia se presentaría de utilizar un capacitor de desacople para $R_3$?
		\end{enumerate}
		\item Laboratorio
		\begin{enumerate}
			\item Implemente el circuito \ref{circuito2} en protoboard y registre la señal en función de la
				señal de la entrada. Modifique la señal de entrada en un $20\%$ y registre el
				cambio de la salida correspondiente. Obtenga a partir de la gráfica el valor
				de $A_V$. (Recuerde que la mayoría de los osciloscopios modernos permiten
				guardar la forma de onda en un dispositivo USB).
			\item Mida $V_{CE}$ e $I_C$ (Si se le dificulta la medición de corriente recuerde 
				que puede calcularlo mediante la medición de $V_{R1}$ y $R_1$)..
		\end{enumerate}
	\end{itemize}
\end{mdframed}

\begin{circuito}[!h]
	\begin{minipage}{.5\textwidth}
		\begin{center}
			\begin{circuitikz}[american,]
				\draw (0,0) node[npn](Q1){$Q_1$};
				\draw (Q1.E) to[R=$R_3$]
				++(0,-3) node[ground](GND){};
				\draw (Q1.C) to[R=$R_1$]
					++(0,3) node[vcc](VCC){$V_{CC}$};
				\draw (Q1.B) to [short] 
					++(-1,0) node[](in){} 
					to[R=$R_4$]
					(in |- GND) node[ground](){};
				\draw (in |- in) to [R=$R_2$, *-] 
					(in |- VCC) node[vcc](){$V_{CC}$};
				\draw (in) ++(0.1,0) to [short, -o] 
					++(-1.5, 0);
				\draw (Q1.C) to [short, *-o] 
					++(1.5, 0);
			\end{circuitikz}
		\end{center}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}
		\begin{center}
			\begin{tabular}{| c | c |}
				\hline
				$Q_1$&BC547\\
				\hline
				$R_1$&$10\kiloohm$\\
				\hline
				$R_2$&$100\kiloohm$\\
				\hline
				$R_3$&$1\kiloohm$\\
				\hline
				$R_4$&$10\kiloohm$\\
				\hline
				$V_{CC}$&$12\volt$\\
				\hline
			\end{tabular}
		\end{center}
	\end{minipage}
\caption{}
\label{circuito1}
\end{circuito}

\begin{equation}
	\beta=520
\end{equation}

\begin{figure}[!ht]
	\begin{center}
	\begin{tikzpicture}[
		declare function={
		recta_de_carga(\x)=
		(\x) * (-1.09/12) + 1.09;
		BJT(\x)= 
		0.445 -
		(1.09) * (e^(0.7/(\x+2.05)) - 1);
		}
	]
	\begin{axis}[
		xmin=0, xmax=13,
		ymin=0, ymax=1.3, ytick={0,0.2,...,1.2},
		axis lines=left,
		domain=0:20,
		xlabel = {$V_{CE} [\volt]$},
		ylabel = {$I_{CQ} [\milliampere]$},
		legend style={at={(1.4,1)}},
	]
	\addplot [mark=none,draw=red]  {BJT(x)};
	\addplot [mark=none,draw=blue] {recta_de_carga(x)};
	\addlegendentry{$I_{BQ}=710\nanoampere$}
	\addlegendentry{Recta de carga}
	\end{axis}
	\draw[gray, dashed] (4.18,0) -- (4.18,1.6);
	\draw[gray, dashed] (0,1.6) -- (4.18,1.6);
	\draw[gray, dashed, <-] (4.18,1.8) -- (4.18,3.2) node[anchor=south]{$(7,93809\volt,369,2\microampere)$};
	\filldraw[black] (4.18,1.6) circle (2pt) node[anchor=south west]{Punto Q};
	\end{tikzpicture}
	\caption{Punto de trabajo}
	\label{fig:PuntoQ}
	\end{center}
\end{figure}

\begin{circuito}[!h]
	\begin{minipage}{.7\textwidth}
			\begin{center}
				\begin{circuitikz}[american,]
					\draw (0,0)  node[above](B){B} 
								to[R=$R_4 // R_2$]
						(0,-3) node[ground](GND){};
						\draw (0,0) to[short, i=$i_b$, *-]
						++(1.5,0);
						\draw (0.6,0) to[R=$R_\pi$, -*]
						++(3,0) node[above](){E} 
								node[](E){} 
								to[R=$R_3$] 
						++(0,-3) node[ground](){};
					\draw (B |- E) to[short] 
						++(-2, 0) node[](supl){}
						to[sV=$V_{in}$] (supl |- GND) 
						node[ground](){};
					\draw (E |- E) to[cisource, l=$h_{fe}\cdot i_b$, invert]
						++(3, 0) node[above](C){C}
						to[R=$R_1$]
						(C |- GND) node[ground](){};
					\draw (C |- E) to [short, *-] 
						++(2,0) node[](out){}
						to[R=$R_5$]
						++(0,-3) node[ground](){};
					\draw (out |- out) to [short, *-o] 
						++(1,0) node[right](){$V_{out}$};
				\end{circuitikz}
		\end{center}
	\end{minipage}%
	\begin{minipage}{.3\textwidth}
		\begin{center}
			\begin{tabular}{| c | c |}
				\hline
				$R_1$&$10\kiloohm$\\
				\hline
				$R_2$&$100\kiloohm$\\
				\hline
				$R_3$&$1\kiloohm$\\
				\hline
				$R_4$&$10\kiloohm$\\
				\hline
				$R_5$&$10\kiloohm$\\
				\hline
				$R_{\pi}$&$42,3\kiloohm$\\
				\hline
				$V_{in}$&$1{\volt}_{pp}$,5kHz\\
				\hline
			\end{tabular}
		\end{center}
	\end{minipage}
\caption{Modelo $R_{\pi}$ equivalente al circuito \ref{circuito2}}
\label{circuito3}
\end{circuito}

\clearpage
\section{Conclusiones}

Se obtuvieron resultados coherentes entre la practica, la simulación y el calculo analítico.
Los resultados no fueron idénticos en cada ámbito, esto es esperable ya que los cálculos fueron
realizados mediante un modelo simplificado, y la simulación es incapaz de ponderar todos los
fenómenos de la naturaleza.\\
Una de las mayores dificultades fue obtener una medición confiable de la diferencia de fase
entre dos señales, al ser ambas sinusoidales fue posible estimar la diferencia de forma 
intuitiva, pero realizar mediciones de ese estilo sobre una señal mas compleja podría traer 
múltiples desafíos.\\
Este amplificador tiene un ancho de banda que parece ir desde aproximadamente $1\kilohertz$,
hasta $1\megahertz$, dentro de este ancho de banda la ganancia es bastante estable, y la fase
se ve consistentemente invertida. Sumado a eso al ser una configuración polarizada en la zona
activa del transistor, tiene un comportamiento muy lineal y no presenta casi distorsión.\\
Por su baja distorsión podría ser usado para audio, aunque solo serviría como un amplificador
de altos. Por su ancho de banda podría utilizarse como un amplificador de radiofrecuencia,
con aplicación marítima de muy baja frecuencia o en AM, aunque su aplicación estaría limitada
a preamplificar por su baja potencia.

\end{document}
